# Messenger

[![Maintainability](https://api.codeclimate.com/v1/badges/7456cf5aaa0a960c3b5f/maintainability)](https://codeclimate.com/github/youngandinnocent/messenger/maintainability)
[![Test Coverage](https://api.codeclimate.com/v1/badges/7456cf5aaa0a960c3b5f/test_coverage)](https://codeclimate.com/github/youngandinnocent/messenger/test_coverage)
[![Build Status](https://travis-ci.org/youngandinnocent/messenger.svg?branch=master)](https://travis-ci.org/youngandinnocent/messenger)

Instant messaging app

# Used by

* [Webpack]
* [Babel]
* [React]
* [Redux]
* ... and other awesome projects

# Guides

* [Введение](#intro)
* [Установка](#setting)
* [Описание проекта](#description)
* [Настройка среды разработки](#environment)
    * [Webpack](#webpack)
    * [Babel](#babel)
* [Приложение](#app)
    * [Архитектура](#architecture)
    * [Контейнеры](#containers)
    * [Компоненты](#components)
    * [npm-модули](#npmmodules)
* [Линтинг и форматирование кода](#lint)
* [Тестирование](#test)
* [Progressive Web App](#pwa)
* [Благодарности](#thanks)

# <a name="intro"></a>Введение

Messenger — приложение для обмена мгновенными сообщениями

### Видеообзор
Кликните на изображение ниже для воспроизведения видео

[![Watch the video](https://img.youtube.com/vi/9_o9vU3l5CA/maxresdefault.jpg)](https://www.youtube.com/watch?v=9_o9vU3l5CA)

### Необходимые инструменты разработки
* [Node.js] - среда разработки приложения, исполняющая JS
* Инструменты для сборки проекта:
    * менеджер пакетов [npm] (или [Yarn])
    * сборщик модулей Webpack - для написания модульного кода
    * компилятор Babel - чтобы писать современный код, который будет работать и в старых браузерах

# <a name="setting"></a>Установка
Склонируйте репозиторий на локальный компьютер:
```sh
$ git clone https://github.com/youngandinnocent/messenger.git
```
Разверните среду разработки проекта (установить все зависимости):
```sh
$ npm i
```
Запустите режим сборки:
```sh
// стандартная разработка
$ npm run dev

// разработка livereload
$ npm run dev-s

// продакшен
$ npm run build
```

# <a name="description"></a>Описание проекта
**Тип приложения:** система мгновенного обмена сообщениями, мессенджер

**Технологии:** React-Redux, SPA, PWA

**Принцип работы приложения:**
* index.html - оболочка для всех страниц
* при первом входе приложение подгружается
* работает в браузере пользователя как клиент, который отрисовывает все страницы и изменения, не ходя за версткой на сервер
* заимодействует с сервером по API, получая данные в JSON
* может работать без подключения к сети (offline first)
* отправляет push-уведомления

**Принципы проектирования:**
* организация файловой структуры проекта по функциональности и методологии Atomic Design
* декларативный код
* flux-архитектура разделения логики, данных и пользовательского интерфейса
* однонаправленный поток данных
* глобальное хранилище на верхнем уровне с доступом к состоянию для компонентов (Redux)
* принцип единственной ответственности (SRP) при разработке компонентов
* паттерн Container/Component в разделении ответственности между разными компонентами
* stateless-компонент должен быть чистой функцией
* типобезопасность данных через использование propTypes
* модульное тестирование
* отладка с React DevTools и Redux DevTools

# <a name="environment"></a>Настройка среды разработки
npm-модули, предназначенные для инструментов разработки, установлены в зависимости разработки (`devDependencies`)

### <a name="webpack"></a>Webpack
Сборщик модулей [Webpack] - инструмент, позволяющий скомпилировать JavaScript-модули в единый JS-файл:
* собрать воедино ресурсы (согласно импортам)
* транспилировать JS нового поколения в JS старого поколения (babel)
* запустить webpack-dev-server (в нём встроен локальный сервер) для разработки в режиме livereload (“живая перезагрузка браузера”))
* выполнить Tree Shaking - метод оптимизации библиотек путем удаления кода из окончательного файла, который фактически не используется

npm-модули для работы с webpack:
* `webpack` - сам бандлер
* `webpack-cli` - набор команд для конфигурации webpack по нужным сценариям исполнения
* `webpack-dev-server` - встроенный локальный сервер для разработки в режиме livereload

Режимы сборки (заданы через скрипты в package.json):
* `webpack --mode development` - стандартная разработка (порт 8080)
* `webpack-dev-server --mode development --port 3000` - разработка в режиме livereload (порт 3000)
* `webpack --mode production` - режим продакшен

Настройка webpack выполнена в файле [webpack.config.js](webpack.config.js) в корне проекта:
* **Точка входа** [./src/index.js](src/index.js) - путь к файлу, с которого начинается сборка проекта
* **Вывод** ./dist/bundle.js - путь к файлу, в который собирается проект
* **Загрузчики модулей** - инструменты webpack, которые определенным образом преобразуют исходный код модулей:
    * для скриптов:
        * babel-loader позволяет webpack транспилировать новый код js и jsx-файлов в старый эквивалент
    * npm-модули:
        * `babel-loader`

    * для стилей:
        * sass-loader загружает scss-файлы и компилирует их в CSS
        * css-loader интерпретирует директиву import 'style.css' в CSS
        * MiniCssExtractPlugin.loader минифицирует файл
        * style-loader внедряет итоговый CSS в DOM, используя тег `<style>`
    * npm-модули:
        * `css-loader`
        * `mini-css-extract-plugin`
        * `sass-loader`
        * `style-loader`

* **Плагины** - программные модули, расширяющие возможности webpack:
    * HTMLWebpackPlugin - автоматически создает HTML-файл с подключенным js-скриптом
        * npm-модули:
            * `html-webpack-plugin`
    
    * MiniCssExtractPlugin - сжимает CSS-файлы
        * npm-модули:
            * `mini-css-extract-plugin`

    * CopyWebpackPlugin - копирует файлы и директории в сборку
        * npm-модули:
            * `copy-webpack-plugin`

* **devtool** - свойство, которое управляет генерацией source map (содержит информацию о том, как транспилировать код обратно в исходный):
    * `eval-source-map` - одна из лучших опций для разработки: первоначально медленный, но обеспечивает быструю скорость восстановления и возвращает исходный код.

* **devServer** - свойство, которое регулирует поведение встроенного сервера
    * `historyApiFallback: true` - сервер отвечает главной страницей на все запросы по незнакомым URL

### <a name="babel"></a>Babel
[Babel] - транспилятор кода стандарта ES6+ в понятный браузерам и средам стандарт.

npm-модули для работы с babel:
* @babel/core - сам транспилятор
* @babel/preset-env - группа плагинов, реализующих стандартизированные возможности js и позволяющих использовать новейший стандарт языка
* @babel/preset-react - преобразование JSX в JS
* babel-loader - настройка для работы в webpack
* @babel/plugin-transform-runtime - оптимизирует сборку и создает изолированную среду для кода проекта
* @babel/plugin-proposal-class-properties - позволяет преобразовывать свойства статического класса, а также использовать синтаксис инициализатора свойств
* babel-jest - для использования в jest

# <a name="app"></a>Приложение
### <a name="architecture"></a>Архитектура
#### Файлововая структура
В корне проекта `/` располагаются все конфиги, связанные с разработкой и сборкой приложения:
* [package.json](package.json) - информация о приложении и зависимостях
* [webpack.config.js](webpack.config.js) - настройки webpack
* [.babelrc](.babelrc) - настройки пресетов и плагинов babel
* [.editorconfig](.editorconfig) - единые настройки для разных редакторов кода и IDE
* [.eslintrc](.eslintrc) - настройки eslint (анализатор кода на ошибки в стандартах написания)
* [.prettierrc](.prettierrc) - правила для prettier (инструмент автоматического форматирования кода)
    
Также в корне расположены директории:
* [dist](dist) - каталог, в который собирается проект
* [coverage](coverage) и [jest](jest) - настройки jest (фреймворк для тестирования) и параметры покрытия кода приложения тестами
* [api](api) - данные для получения (имитация данных с сервера)
* [src](src) - директория с исходным кодом приложения

#### src
* Точка входа проекта - [/src/index.js](src/index.js), оболочка для всех страниц - [/src/index.html](src/index.html)

* Здесь же определены:
    * [store.js](/src/store.js) - единое хранилище всего состояния приложения
    * [actions](/src/actions) - структуры, отправляющие данные с намерением изменить состояние в хранилище
    * [reducers](/src/reducers) - функции, которые обрабатывают данные от actions и изменяют состояние хранилища
    * [middlewares](/src/middlewares) - программы, усиливающие и расширяющие функционал приложения, перехватывают данные от actions -> вносят нужные изменения -> модифицированные данные попадают в редуктор, который меняет хранилище

    * [components](/src/components) - компоненты приложения, не подключенные к хранилищу, преимущественно отвечающие за пользовательский интерфейс
    * [containers](/src/containers) - компоненты, которые подключены к хранилищу и отвечают за бизнес-логику

    * [routes.js](/src/routes.js) - роутинг, обеспечивающий маршрутизацию по страницам приложения

    * [sw.js](/src/sw.js) - service worker - основа PWA (прогрессивное web-приложение), посредник между клиентом и сервером, отправляющий нужные данные в качестве ответа
    * [manifest.json](/src/manifest.json) - часть технологии PWA, предоставляет клиенту информацию о приложении
    * [assets](/src/assets) - набор иконок для PWA

#### Архитектура приложения
Архитектура приложения обусловлена однонаправленным потоком данных React, что затрудняет взаимодействие компонентов, не связанных отношениями родителя и потомка.
В качестве решения используется паттерн [Flux](https://facebook.github.io/flux/) и реализация технологии, основанной на нем - [Redux].
Таким образом, архитектура приложения представляет из себя:
* единоe глобальноe хранилищe **store**, к которому подключены
* суперкомпоненты, называемые **containers**, способные посылать запросы на изменение данных в хранилище и регулирующие эти допуски для компонентов
* дерево компонентов - **компоненты**, которые реализуют пользовательский интерфейс приложения
![](scheme.png)

#### Хранилище
Глобальное хранилище включает три логических раздела, каждому из которых назначены соответствующие редукторы, объединенные в один объект в точке входа в редукторы:
```sh
// файл /reducers/index.js

...
router: connectRouter(history) // редуктор роутинга для работы Redux в React Router,
                               // принимает объект history, который хранит путь к текущему location
chats: chatsReducers // редуктор чатов
profile: profileReducers // редуктор профиля
```

Каждый редуктор передает соответствующий раздел общего состояния. Состояние, возвращенное редуктором, попадет в его раздел.
Согласно документации Redux, во избежание появления ошибок объект состояния должен быть иммутабельным.
Для этого в имплементации редукторов используется оператор расширения `...` и библиотека `react-addons-update`, которая упрощает поддержку неизменяемости данных без существенной переработки этих данных:
```sh
// файл /reducers/chats.js

import update from 'react-addons-update';
import {
// other actions
CHATS_DELETE,
} from 'actions/chats';

const initialState = {
    // some state
};

export default (state = initialState, action) => {
    switch (action.type) {
        // other cases
        case CHATS_DELETE:
        return update(state, {
            $merge: { // команда библиотеки react-addons-update, возвращающая новый объект,
                      //полученный из соединения предыдущего и заданного
            entries: { ...action.payload.newState },
            },
        });
    }
};
```

#### Контейнеры
Контейнеры подключены к хранилищу с помощью модуля react-redux, функцией `connect()`.
`connect()` связывает данные из контейнера со свойствами конкретного компонента.
Принимает два аргумента:
* `mapStateToProps` - функция, которая возвращает объект, свойства которого станут свойствами контейнера. Принимает состояние, от которого и берутся свойства возвращаемого объекта.
* `mapDispatchToProps` - функция, которая возвращает объект с actions. Также станет свойством контейнера. Тут же вызывается анонимная функция, которой передается компонент LayoutContainer.
```sh
// файл /containers/LayoutContainer.jsx

...
export const LayoutRedux = connect(mapStateToProps, mapDispatchToProps)(LayoutContainer);
```

Хранилище имеет API для изменения состояния приложением - `store.dispatch(action)`.
Метод `dispatch()` передает `action` в Redux. `action` содержит тип действия и может содержать данные,
которые используются для обновления состояния:
```sh
// файл /src/actions/chats.js

...
export const chatsDelete = (newState) => ({
    type: CHATS_DELETE,
    payload: newState,
});
```

Для работы технологии react-redux приложение в точке входа оборачивается в компонент `<Provider />`:
```sh
// файл /src/index.js
...
ReactDom.render(
    <Provider store={store}>
        // React Router
    </Provider>,
    document.getElementById('root'),
);
```
#### Компоненты
Структура дерева компонентов организована по функциональности с применением методологии atomic design.
Компоненты сгруппированы в каталоги по назначению с одноименным названием, в которых находятся файлы исходного кода компонента, стили и тесты, имеющие доменные имена как у родительских каталогов:
![](structure.png)

Для удобства импорта компонентов предназначена точка входа в компонент - **/ConponentName/index.js**,
который реэкспортирует модуль компонента, а Webpack по умолчанию находит его и согласно импортам
собирает весь компонент:
```sh
// файл /**/**/Message/index.js

export * from './Message';
```

Компонент описан в jsx-файле, в который импортированы модули React, прочие служебные библиотеки,
стили и другие компоненты (если у компонента есть потомки):
```sh
// файл /**/**/Message/Message.jsx

import React from 'react';
import PropTypes from 'prop-types';
import className from 'classnames';

import './Message.scss';

export function Message(props) {
    // some code
};
```

Стили компонента заданы в `css/scss-файле`.
Тесты располагаются в каталоге `__tests__`.

### <a name="containers"></a>Контейнеры
#### /src/containers
Контейнеры представляют из себя компоненты, которые, в отличие от обычных, подключены к Redux, и поэтому могут посылать запросы к глобальному хранилищу на изменение данных.
Это возможно благодаря механизму `dispatch(actions)` -> `reducer` -> `store`:
`action` направляется в хранилище с помощью метода `dispatch()` -> проходит через свой `reducer` -> `reducer` меняет `store` в своей части

Контейнеры реализуют две линии поведения приложения:
* **LayoutContainer** - функционал, отвечающий за работу чатов и их составляющих
* **ProfileContainer** - функционал страницы профиля (редактирование имени и описания профиля)

Контейнеры предоставляют компонентам API для запросов на изменение данных в глобальном хранилище,
и пробрасывают им пропсы с данными, на которые компоненты подписаны. Когда данные в хранилище меняются, компоненты автоматически обновляются.

#### API контейнеров
* Общие методы:
    * `handleNavigate(link)` - навигация по страницам приложения
* LayoutContainer:
    * `handleMessageSend(messageObj)` - отправить сообщение в чат
    * `handleChatAdd(chatObj)` - добавить новый чат
    * `handleChatDelete(chatId)` - удалить чат

* ProfileContainer:
    * `handleForm(formObj)` - редактировать название и описание профиля

Для демонстрации поливариантности React контейнер **LayoutContainer** реализован на классах, а контейнер **ProfileContainer** - на хуках.

### <a name="components"></a>Компоненты
#### /src/components
Компоненты выполняют функцию представления элементов пользовательского интерфейса. А также могут
реализовывать локальную бизнес-логику на уровне компонента.
Компоненты без состояния описываются чистыми функциями, компоненты с состоянием - классами.
Часть элементов, из которых состоят компоненты (кнопки, иконки), импортируются из библиотеки [@material-ui](https://material-ui.com)

Каждый компонент, помимо данных от родителей, может получать данные из хранилища через `props`, но не каждый может иметь право на запрос для изменения этих данных в хранилище.
Если у компонента есть допуск от контейнера (предоставлено API) на изменение данных, компонент:
* вызывает соответствующий метод и передает в него нужные данные
* метод отрабатывает в компоненте с нужными данными благодаря замыканию
* вызывается соответствующий для данного метода `action` и направляется в хранилище через `dispatch()`
* прежде чем попасть в `reducer`, каждый вызванный `action` проходит через цепочку `middlewares` (при наличии)
* далее `action` проходит через соответствующий `reducer`
* `reducer` вносит изменения в свою часть хранилища
* компоненты, подписанные на данные изменения в хранилище, обновляют свои состояния

### <a name="npmmodules"></a>npm-модули
#### модули React
* `react` - библиотека React
* `react-dom` - билиотека для работы React с DOM
* `prop-types` - проверка и кастомизация по умолчанию типов пропсов
* `react-addons-update` - библиотека для иммутабельности данных
* `react-router-dom` - библиотека для роутинга в браузере

#### модули Redux
* `redux` - библиотека Redux
* `react-redux` - библиотека для работы Redux в React
* `connected-react-router` - привязывает Redux к React Router
* `redux-actions` - набор хелперов для работы с экшенами
* `redux-thunk` - middleware библиотека для асинхронных экшенов в Redux
* `redux-persist` - сохранение и восстановление состояния хранилища
* `redux-devtools-extension` - инструмент отладки изменений состояния приложения

#### прочие вспомогательные библиотеки
* `history` - библиотека для навигации по истории сеансов
* `classnames` - библиотека для удобства работы с классами элементов
* `@material-ui/core` - библиотека React-компонентов

# <a name="lint"></a>Линтинг и форматирование кода
#### ESLint
Анализатором кода на ошибки в стандартах написания и паттернах проектирования (линтинг) служит [ESLint](https://eslint.org).
* База стиля - [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript).
* Настройки и правила заданы в [.eslintrc](.eslintrc) в корне проекта. Файлы и папки, которые не должны обрабатываться ESlint, заданы в [.eslintignore](.eslintignore).
* Скрипт для выполнения ESlint: `eslint --debug src` - линтер просмотрит все файлы в директории src и выведет подробный отчёт по файлам, в которых нашёл ошибки

* **npm-модули:**
    * `eslint` - библиотека ESLint
    * `babel-eslint` - позволяет ESLint работать с исходным кодом, преобразованным Babel
    * `eslint-plugin-babel` - плагин, дополняющий `babel-eslint`, в нём переделаны правила, которые вызывают проблемы при обработке экспериментальных возможностей
    * `eslint-config-airbnb` - предоставляет правила Airbnb в виде конфигурации, которую можно модифицировать
    * `eslint-plugin-import` - поддерживает линтинг синтаксических конструкций `import/export`
    * `eslint-plugin-react` - содержит ESLint-правила, рассчитанные на React
    * `eslint-plugin-jsx-a11y` - доступность JSX-элементов для людей с ограниченными возможностями
    * `eslint-plugin-jest` - ESlint-плагин для работы с Jest
    * `eslint-config-jest-enzyme` - когда переменные React и Enzyme оказываются глобальными, ESLint не будет выдавать предупреждения

#### Prettier
Автоматическое форматирование кода обеспечивается средством [Prettier](https://prettier.io), которое нацелено на использование жёстко заданных правил по оформлению программ.
* Конфигурация работы инструмента описана в [.prettierrc](.prettierrc) в корне проекта.
* Скрипт для выполнения Prettier: `prettier --write src` - Prettier находит все файлы в папке **src** и форматирует их согласно правилам.

* **npm-модули:**
    * `prettier` - библиотека Prettier
    * `eslint-plugin-prettier` - Prettier форматирует код с учётом правил ESLint

#### Husky и Lint-staged
Инструмент управления Git hooks - возможность выполнять определенные действия перед выполнением коммита или перед отправкой кода в репозиторий - [Husky](https://github.com/typicode/husky).
И линтер индексированных файлов - [Lint-staged](https://github.com/okonet/lint-staged) - помогает предотвратить отправку в репозиторий кода с ошибками
* Конфигурация работы инструментов описана в [package.json](package.json).
* Перед коммитом в Git выполняется Husky, который запускает скрипт lint-staged, который для файлов js и jsx запускает набор команд:
    * `npm run prettier && npm run eslint && npm run test` - отформатировать код, проверить линтером и запустить тесты
    * `git add` - и, при успешном выполнении предыдущей команды, добавляет в индекс

* **npm-модули:**
    * `husky` - библиотека Husky
    * `lint-staged` - библиотека lint-staged

#### EditorConfig
Для поддержки согласованного стиля кодирования в мультиплатформенных командах настроен конфигурационный файл [EditorConfig](.editorconfig) в корне проекта.

# <a name="test"></a>Тестирование
В проекте реализовано **модульное тестирование** (рендеринг деревьев компонентов) и заложены предпосылки для интеграционного тестирования («сквозные» тесты).

#### Запуск тестов:
`npm run test` - по окончании выводит отчет по каждому тесту и глубину покрытия тестами отдельных компонентов и всего приложения (текущий статус - 80% покрытия)

#### Инструменты тестирования:
* [Jest](https://jestjs.io) - тестовый фреймворк, основной инструмент тестирования кода, исполнитель тестов на JavaScript, который позволяет взаимодействовать с DOM через **jsdom**. Конфигурация задана в [package.json](package.json).
* [Enzyme](https://enzymejs.github.io/enzyme/) - библиотека от Airbnb, предоставляющая интуитивно понятный и удобный API для тестирования.
* **ReactTestUtils** - встроенная в React тестовая утилита, которая позволяет легко тестировать компоненты в Jest.

#### Стратегии тестирования:
* **Тестирование отрисовки компонентов и props** - выполняется для компонентов без состояния:
    * Snapshot-тестирование
    * поверхностный (shallow) рендеринг
* **Тестирование логики компонентов** - выполняется для контейнеров и компонентов с состоянием:
    * тестирование состояния компонентов
    * тестирование обработчиков событий

Тесты каждого компонента находятся в папке **__tests__**, расположенной в корне папки компонента. Например, тесты для [/src/components/Message/Message.jsx](/src/components/Message/Message.jsx) расположены в [/src/components/Message/__tests__/Message.test.js](/src/components/Message/__tests__/Message.test.js).

Для каждого теста выполняется подготовка данных или рендерится React-дерево к DOM-элементу, который прикреплён к document. По завершении теста дерево размонтируется от document, чтобы тесты не "текли".
Для реализации этого функционала используются блоки `beforeEach` и `afterEach`.

#### npm-модули:
* `jest` - тестовый фреймворк Jest
* `enzyme` - библиотека тестирования React-компонентов
* `enzyme-adapter-react-16` - утилита, обеспечивающая совместимость Enzyme и React
* `pretty` - красивое форматирование снапшотов jest

#### Инструменты отладки приложения в браузере:
* [React DevTools](https://www.npmjs.com/package/react-devtools) - работа с иерархией компонентов, их свойствами и состоянием
* [Redux DevTools](https://www.npmjs.com/package/redux-devtools) - работа с хранилищем

# <a name="pwa"></a>Progressive Web App
[Progressive Web App](https://web.dev/progressive-web-apps/) — возможность скачивать мобильную браузерную версию на телефон и использовать как полноценное приложение. Также это возможность листать сайт в оффлайне как с мобильного устройства, так и с компьютера с единой кодовой базой. Такое приложение работает на любой платформе, имеет современный материальный дизайн и высокую скорость загрузки, а также отлично оптимизируется в поисковой выдаче.

#### Преимущества PWA:
* мгновенная установка приложения (все загружено в кеш при первом посещении сайта)
* легкое приложение (быстро запускается, быстро работает)
* работает на любой платформе (Android, macOS, iOS, Windows, Linux, Chrome OS), в любом браузере и на любом экране
* работает в атономном режиме без доступа к сети (подгружает данные и кеширует)
* устанавливается на главный экран и запускается в отдельном окне на полный экран, как и нативное приложение (привычный UX)
* полная доступность для использования (в том числе, людям с ограниченными возможностями)
* работает с любым типом ввода (мышь, клавиатура, сенсорный экран и т.д.)
* запросы на разрешение по использованию мощных API предоставляет в контексте UX 
* широкая доступность для установки, не ограниченная App Store или Google Play
* умное предложение по установке (при проявления интереса пользователя к приложению)
* весь функционал (push-уведомления, работа в оффлайн) доступен даже без установки приложения
* бесплатная модель распространения (не нужно платить магазинам Apple App Store или Google Play Store)

#### Недостатки PWA:
* малая популярность PWA среди пользователей
* технологию поддерживают не все браузеры
* работает чуть медленнее, чем нативное приложение
* меньше доступа к устройствам, чем у нативного приложения
* дополнительный уровень абстракции в виде service worker
* обязательное требование протокола HTTPS


#### Стек технологий PWA:
* [Service-worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) - сердце PWA, проксирующий слой между фронтэндом и бэкэндом
* [Web App manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest) - описание и правила установки приложения для клиента
* [Background Sync](https://developers.google.com/web/updates/2015/12/background-sync) - фоновая синхронизация данных
* [Push Notifications](https://developer.mozilla.org/en-US/docs/Web/API/Push_API) - технология принудительной доставки данных с сервера клиенту
* [HTTPS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview) - безопасный протокол
* [Application Shell](https://developers.google.com/web/fundamentals/architecture/app-shell) - каркас пользовательского интерфейса, статика
* [Seamless sign-in and sign-up flows](https://developers.google.com/identity/one-tap/web) - регистрация одним касанием и автоматический вход на сайты
* [WebShare API](https://www.w3.org/TR/web-share/) - шаринг, обмен любым содержимым одной кнопкой
* [Payment Request API](https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API) - поддержка платежей

#### Service-worker
Service-worker - скрипт, который браузер запускает в фоновом режиме, отдельно от страницы, и способен
выполнять функции, для которых не требуется взаимодействие со страницей или пользователем.
* Ключевая особенность SW — это возможность перехватывать и обрабатывать сетевые запросы, включая программное управление кэшированием ответов.
* SW выполняет такие функции, как push-уведомления и фоновая синхронизация.
* SW запускается в worker-контексте, поэтому он не имеет доступа к DOM и работает в потоке, отдельном от основного потока JavaScript, управляющего приложением, а следовательно — не блокирует его.
* Service-worker асинхронный.
* SW работает только по HTTPS из соображений безопасности. В режиме разработки доступен на localhost 127.0.0.1

В [index.html](src/index.html) в корне **src** подключен скрипт, в котором происходит регистрация service-worker, разрешение на отправку push-уведомлений, а также отслеживание установок приложения.

В файле [sw.js](src/sw.js) в корне **src** определены базовые события, которые обрабатывает SW: установка, запросы на сервер, а также описана логика работы push-уведомлений и процесса синхронизации с сервером.

Стратегия кэширования и фоновой синхронизации, реализованная в приложении - **Cache and lazy update:**
* при первом открытии сайта service worker устанавливается в браузер пользователя.
При регистрации SW складывает в кэш указанные ресурсы - чтобы приложение было отзывчивым, кэшируются все статичные файлы: js, css, медиаконтент.
* при каждом запросе на сервер, SW сначала отвечает из кэша, чтобы доставить быстрые ответы, а при запросе новых данных идет за ними на сервер.

#### Манифест
Манифест — это json файл, объясняющий, как приложение должно вести себя, когда установлено. JSON файл, декларативно определяющий для браузера название приложения, иконку, как будет выглядеть PWA (fullscreen, standalone и др.) и некоторые другие параметры. Позволяет «установить» PWA как отдельное приложение на домашний экран смартфона.
Конфигурация Манифест описана в [manifest.json] в корне **src**.
Подключается Манифест в браузер в файле **index.html** ссылкой `<link rel="manifest" href="/manifest.json">`.
Картинки для иконок разных размеров, заданных в Манифесте, находятся в директории [api/assets/image](api/assets/image).

#### Адаптивный дизайн
Используя технологии адаптивного дизайна, **Progressive Web Apps** работают на мобильных и десктопах c
единой базой кода. Адаптивный дизайн приложения реализован с помощью медиазапросов под разный размер
экрана, что позволяет приложению работать на основных устройствах: ПК, ноутбук, планшет, смартфон.
Медиазапросы описаны в файлах стилей компонентов, например, стили компонента [src/components/Layout/Layout.jsx](src/components/Layout/Layout.jsx) хранятся в [src/components/Layout/Layout.css](src/components/Layout/Layout.css).

#### Аудит приложения
Инструмент [Lighthouse](https://developers.google.com/web/tools/lighthouse) позволяет тестировать, отлаживать и улучшать PWA.
Его можно установить как расширение или воспользоваться встроенным в Google Chrome во вкладке Audit.
При генерации отчета Lighthous вернет анализ приложения в целом, а также проверку на соответствие стандарту Progressive Web App.
Текущий отчет Lighthous (из 100):
* Performance - 4
* Accessibility - 73
* Best Practices- 86
* SEO - 91
* Progressive Web App - 75

*Первый пункт - производительность - очень низкая из-за того, что сайт работает в dev-режиме и приложение не минимизировано (не сжато). На боевом сервере этот показатель будет в норме.

### npm-модули:
* `http-server` - http-сервер для тестирования и локальной разработки

# <a name="#thanks"></a>Благодарности
Я хотел бы поблагодарить ребят из проекта стажировки [ВТБ](https://habr.com/ru/company/vtb/) за любезно предоставленную мне такую возможность. Команде [GeekBrains](https://habr.com/ru/company/geekbrains/) за организацию обучения на проекте. Спасибо преподавателю [Гайку](https://github.com/HaykInanc) за то, что давал задачки, над которыми приходилось очень хорошо подумать :)
И отдельно хотел бы сказать огромное спасибо преподавателю [Игорю Филимонову](https://github.com/iwebexpert), который помог мне освоить технологии разработки приложений на React-Redux. Очень доступно разъяснял материал, проводя подробные кодревью и детально отвечя на мои бесконечные и не всегда правильные вопросы. Спасибо! Всем удачи и добра :)

[Webpack]: <https://webpack.js.org>
[Babel]: <https://babeljs.io>
[React]: <https://reactjs.org>
[Redux]: <https://redux.js.org>
[Node.js]: <https://nodejs.org/en/>
[npm]: <https://www.npmjs.com>
[Yarn]: <https://yarnpkg.com>